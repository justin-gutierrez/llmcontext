# fastapi Documentation - Chunk 3 (Original)

**Original File:** fastapi_hybrid_000_sub_02.md

---

# fastapi_hybrid_000_sub_02

**Metadata:** {'strategy': 'hybrid', 'header_level': 1, 'line_count': 7, 'document_id': 'fastapi', 'sub_chunk_index': 2, 'total_sub_chunks': 4}

**Tokens:** 2000-3000

---

loader process [2248755] using WatchFiles INFO: Started server process [2248757] INFO: Waiting for application startup. INFO: Application startup complete. About the command fastapi dev main.py... The command fastapi dev reads your main.py file, detects the FastAPI app in it, and starts a server using Uvicorn. By default, fastapi dev will start with auto-reload enabled for local development. You can read more about it in the FastAPI CLI docs.

 Check it&para; Open your browser at http://127.0.0.1:8000/items/5?q=somequery. You will see the JSON response as: {&quot;item_id&quot;: 5, &quot;q&quot;: &quot;somequery&quot;} You already created an API that: Receives HTTP requests in the paths / and /items/{item_id}. Both paths take GET operations (also known as HTTP methods). The path /items/{item_id} has a path parameter item_id that should be an int. The path /items/{item_id} has an optional str query parameter q. Interactive API docs&para; Now go to http://127.0.0.1:8000/docs. You will see the automatic interactive API documentation (provided by Swagger UI): Alternative API docs&para; And now, go to http://127.0.0.1:8000/redoc. You will see the alternative automatic documentation (provided by ReDoc): Example upgrade&para; Now modify the file main.py to receive a body from a PUT request. Declare the body using standard Python types, thanks to Pydantic. from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str price: float is_offer: Union[bool, None] = None @app.get(&quot;/&quot;) def read_root(): return {&quot;Hello&quot;: &quot;World&quot;} @app.get(&quot;/items/{item_id}&quot;) def read_item(item_id: int, q: Union[str, None] = None): return {&quot;item_id&quot;: item_id, &quot;q&quot;: q} @app.put(&quot;/items/{item_id}&quot;) def update_item(item_id: int, item: Item): return {&quot;item_name&quot;: item.name, &quot;item_id&quot;: item_id} The fastapi dev server should reload automatically. Interactive API docs upgrade&para; Now go to http://127.0.0.1:8000/docs. The interactive API documentation will be automatically updated, including the new body: Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API: Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen: Alternative API docs upgrade&para; And now, go to http://127.0.0.1:8000/redoc. The alternative documentation will also reflect the new query parameter and body: Recap&para; In summary, you declare once the types of parameters, body, etc. as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python. For example, for an int: item_id: int or for a more complex Item model: item: Item ...and with that single declaration you get: Editor support, including: Completion. Type checks. Validation of data: Automatic and clear errors when the data is invalid. Validation even for deeply nested JSON objects. Conversion of input data: coming from the network to Python data and types. Reading from: JSON. Path parameters. Query parameters. Cookies. Headers. Forms. Files. Conversion of output data: converting from Python data and types to network data (as JSON): Convert Python types (str, int, float, bool, list, etc). datetime objects. UUID objects. Database models. ...and many more. Automatic interactive API documentation, including 2 alternative user interfaces: Swagger UI. ReDoc. Coming back to the previous code example, FastAPI will: Validate that there is an item_id in the path for GET and PUT requests. Validate that the item_id is of type int for GET and PUT requests. If it is not, the client will see a useful, clear error. Check if there is an optional query parameter named q (as in http://127.0.0.1:8000/items/foo?q=somequery) for GET requests. As the q parameter is declared with = None, it is optional. Without the None it would be required (as is the body in the case with PUT). For PUT requests to /items/{item_id}, read the body as JSON: Check that it has a required attribute name that should be a str. Check that it has a required attribute price that has to be a float. Check that it has an optional attribute is_offer, that should be a bool, if present. All this would also work for deeply nested JSON objects. Convert from and to JSON automatically. Document everything with OpenAPI, that can be used by: Interactive documentation systems.